# –ó–∞–¥–∞—á–∞ 3.4: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å offer/answer –æ–±–º–µ–Ω

## –û–±–∑–æ—Ä

–£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ P2P —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –º–µ–∂–¥—É –¥–≤—É–º—è —É—á–∞—Å—Ç–Ω–∏–∫–∞–º–∏ —á–µ—Ä–µ–∑ exchange SDP offer/answer.

## üéØ –¶–µ–ª—å

- –ò–Ω–∏—Ü–∏–∞—Ç–æ—Ä —Å–æ–∑–¥–∞—ë—Ç –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç offer
- –ü—Ä–∏–Ω–∏–º–∞—é—â–∞—è —Å—Ç–æ—Ä–æ–Ω–∞ —Å–æ–∑–¥–∞—ë—Ç –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç answer
- –û–±–µ —Å—Ç–æ—Ä–æ–Ω—ã —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é—Ç remote description
- ICE –∫–∞–Ω–¥–∏–¥–∞—Ç—ã –æ–±–º–µ–Ω–∏–≤–∞—é—Ç—Å—è
- –í–∏–¥–µ–æ –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è —É –æ–±–æ–∏—Ö —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤

## üìö –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–µ

[WebRTC Signalling flow (MDN)](https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling)

## üìù –†–µ–∞–ª–∏–∑–∞—Ü–∏—è

### –ü–æ–ª–Ω—ã–π hook –¥–ª—è WebRTC

```typescript
// apps/client/src/hooks/use-webrtc.ts
import { useState, useEffect, useRef, useCallback } from 'react';
import { socket } from '../lib/socket';
import { iceServers } from '../lib/config';

export function useWebRTC(roomId: string, localStream: MediaStream | null) {
  const [remoteStreams, setRemoteStreams] = useState<Map<string, MediaStream>>(new Map());
  const peerConnections = useRef<Map<string, RTCPeerConnection>>(new Map());

  // –°–æ–∑–¥–∞—Ç—å peer connection –¥–ª—è —É—á–∞—Å—Ç–Ω–∏–∫–∞
  const createPeerConnection = useCallback((socketId: string): RTCPeerConnection => {
    if (peerConnections.current.has(socketId)) {
      return peerConnections.current.get(socketId)!;
    }

    const pc = new RTCPeerConnection(iceServers);

    // –î–æ–±–∞–≤–∏—Ç—å –ª–æ–∫–∞–ª—å–Ω—ã–µ —Ç—Ä–µ–∫–∏
    localStream?.getTracks().forEach(track => {
      pc.addTrack(track, localStream);
    });

    // –û–±—Ä–∞–±–æ—Ç–∞—Ç—å –≤—Ö–æ–¥—è—â–∏–π —Ç—Ä–µ–∫
    pc.ontrack = (event) => {
      const stream = event.streams[0];
      if (stream) {
        setRemoteStreams(prev => new Map(prev).set(socketId, stream));
      }
    };

    // ICE –∫–∞–Ω–¥–∏–¥–∞—Ç—ã
    pc.onicecandidate = (event) => {
      if (event.candidate) {
        socket.emit('ice_candidate', {
          roomId,
          candidate: event.candidate,
          to: socketId,
        });
      }
    };

    peerConnections.current.set(socketId, pc);
    return pc;
  }, [localStream, roomId]);

  // –°–æ–∑–¥–∞—Ç—å offer (–¥–ª—è –∏–Ω–∏—Ü–∏–∞—Ç–æ—Ä–∞)
  const createOffer = useCallback(async (targetSocketId: string) => {
    const pc = createPeerConnection(targetSocketId);
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);

    socket.emit('offer', {
      roomId,
      offer,
      to: targetSocketId,
    });
  }, [roomId, createPeerConnection]);

  // –û–±—Ä–∞–±–æ—Ç–∞—Ç—å –≤—Ö–æ–¥—è—â–∏–π offer
  useEffect(() => {
    socket.on('offer', async ({ offer, from, roomId: offerRoomId }) => {
      if (offerRoomId !== roomId) return;

      const pc = createPeerConnection(from);
      await pc.setRemoteDescription(offer);

      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);

      socket.emit('answer', {
        roomId,
        answer,
        to: from,
      });
    });

    return () => { socket.off('offer'); };
  }, [roomId, createPeerConnection]);

  // –û–±—Ä–∞–±–æ—Ç–∞—Ç—å –≤—Ö–æ–¥—è—â–∏–π answer
  useEffect(() => {
    socket.on('answer', async ({ answer, from, roomId: answerRoomId }) => {
      if (answerRoomId !== roomId) return;

      const pc = peerConnections.current.get(from);
      if (pc) {
        await pc.setRemoteDescription(answer);
      }
    });

    return () => { socket.off('answer'); };
  }, [roomId]);

  // –û–±—Ä–∞–±–æ—Ç–∞—Ç—å ICE –∫–∞–Ω–¥–∏–¥–∞—Ç—ã
  useEffect(() => {
    const iceCandidatesQueue = new Map<string, RTCIceCandidateInit[]>();

    socket.on('ice_candidate', async ({ candidate, from, roomId: candidateRoomId }) => {
      if (candidateRoomId !== roomId) return;

      const pc = peerConnections.current.get(from);

      if (pc?.remoteDescription) {
        await pc.addIceCandidate(candidate);
      } else {
        // –û—á–µ—Ä–µ–¥—å –µ—Å–ª–∏ remoteDescription –µ—â—ë –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω
        if (!iceCandidatesQueue.has(from)) {
          iceCandidatesQueue.set(from, []);
        }
        iceCandidatesQueue.get(from)!.push(candidate);
      }
    });

    return () => { socket.off('ice_candidate'); };
  }, [roomId]);

  // Cleanup
  useEffect(() => {
    return () => {
      peerConnections.current.forEach(pc => pc.close());
      peerConnections.current.clear();
    };
  }, []);

  return {
    remoteStreams,
    createOffer,
  };
}
```

### –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≤ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–µ

```typescript
export default function RoomPage() {
  const { localStream } = useLocalMedia();
  const { remoteStreams, createOffer } = useWebRTC(roomId, localStream);

  useEffect(() => {
    // –ü—Ä–∏ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–∏ –Ω–æ–≤–æ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞
    socket.on('user_joined', ({ socketId }) => {
      createOffer(socketId);
    });

    return () => { socket.off('user_joined'); };
  }, [createOffer]);

  return (
    <div className="grid grid-cols-2 gap-4">
      <LocalVideo stream={localStream} />
      {Array.from(remoteStreams.entries()).map(([socketId, stream]) => (
        <RemoteVideo key={socketId} stream={stream} />
      ))}
    </div>
  );
}
```

## ‚ö†Ô∏è –í–∞–∂–Ω—ã–µ –Ω—é–∞–Ω—Å—ã

### 1. Perfect Negotiation

–î–ª—è —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω–æ–≥–æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è (–∫–æ–≥–¥–∞ –ª—é–±–æ–π –º–æ–∂–µ—Ç –Ω–∞—á–∞—Ç—å):

```typescript
const polite = localStorage.getItem('polite') === 'true';
const pc = new RTCPeerConnection({ iceServers });

pc.onnegotiationneeded = async () => {
  try {
    await pc.setLocalDescription();
    socket.emit('description', { description: pc.localDescription });
  } catch (e) {
    console.error(e);
  }
};

socket.on('description', async ({ description }) => {
  const offerCollision = description.type === 'offer' &&
    (makingOffer || pc.signalingState !== 'stable');

  ignoreOffer = !polite && offerCollision;

  if (ignoreOffer) return;

  await pc.setRemoteDescription(description);

  if (description.type === 'offer') {
    await pc.setLocalDescription();
    socket.emit('description', { description: pc.localDescription });
  }
});
```

### 2. ICE candidates queue

```typescript
const candidatesQueue: RTCIceCandidateInit[] = [];

socket.on('ice_candidate', async ({ candidate, from }) => {
  const pc = peerConnections.get(from);

  if (pc?.remoteDescription) {
    await pc.addIceCandidate(candidate);
  } else {
    candidatesQueue.push(candidate);
  }
});

socket.on('offer', async ({ offer, from }) => {
  const pc = createPeerConnection(from);
  await pc.setRemoteDescription(offer);

  // –î–æ–±–∞–≤–∏—Ç—å –Ω–∞–∫–æ–ø–∏–≤—à–∏–µ—Å—è –∫–∞–Ω–¥–∏–¥–∞—Ç—ã
  for (const candidate of candidatesQueue) {
    await pc.addIceCandidate(candidate);
  }
  candidatesQueue.length = 0;
});
```

### 3. Cleanup –ø—Ä–∏ disconnect

```typescript
socket.on('user_left', ({ socketId }) => {
  const pc = peerConnections.current.get(socketId);
  if (pc) {
    pc.close();
    peerConnections.current.delete(socketId);
  }

  setRemoteStreams(prev => {
    const next = new Map(prev);
    next.delete(socketId);
    return next;
  });
});
```

## ‚úÖ –ö—Ä–∏—Ç–µ—Ä–∏–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è

- [ ] Offer —Å–æ–∑–¥–∞—ë—Ç—Å—è –ø—Ä–∏ join –Ω–æ–≤–æ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞
- [ ] Answer —Å–æ–∑–¥–∞—ë—Ç—Å—è –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ offer
- [ ] Remote description —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç—Å—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ
- [ ] ICE –∫–∞–Ω–¥–∏–¥–∞—Ç—ã –¥–æ–±–∞–≤–ª—è—é—Ç—Å—è –±–µ–∑ –æ—à–∏–±–æ–∫
- [ ] –î–≤–∞ –≤–∫–ª–∞–¥–∫–∏ –≤–∏–¥—è—Ç –≤–∏–¥–µ–æ –¥—Ä—É–≥ –¥—Ä—É–≥–∞
- [ ] –ü—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ –≤–∫–ª–∞–¥–∫–∏ peer connection –∑–∞–∫—Ä—ã–≤–∞–µ—Ç—Å—è

## üß™ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ

1. –û—Ç–∫—Ä–æ–π –¥–≤–µ –≤–∫–ª–∞–¥–∫–∏ –±—Ä–∞—É–∑–µ—Ä–∞
2. –ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Å—å –∫ –æ–¥–Ω–æ–π –∫–æ–º–Ω–∞—Ç–µ
3. –ü—Ä–æ–≤–µ—Ä—å –∫–æ–Ω—Å–æ–ª–∏: offer/answer –æ–±–º–µ–Ω
4. –ü—Ä–æ–≤–µ—Ä—å –≤–∏–¥–µ–æ –≤ –æ–±–µ–∏—Ö –≤–∫–ª–∞–¥–∫–∞—Ö

## üéÆ –°–ª–µ–¥—É—é—â–∞—è: [–ó–∞–¥–∞—á–∞ 3.5: Mute/Unmute](./3.5-mute-unmute.md)
